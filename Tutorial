// das ist ein showcase von Kotlin

//hiermit integrierst du Libraries um z.B. bestimmte Befehle oder Objekte nutzen zu k√∂nnen
//sie gehh√∂ren immer √ºber irgendwas
import java.util.*

/**
 * class Tutrial{
 * -> das ist theoretisch eine Klasse und hier schreibst du den ganzen Code rein(normalerweise!), aber
 *    wir brauchen nur den Playground und arbeiten noch nicht mit externen Klassen ;)
 * }
 * **/

// eine fun deklariert eine Methode, die du aufrufen kannst und dann irgendwas tut
// das in der Klammer ist der Parameter, den du dieser Funktion √ºbergiebst
// eine main Funktion wird *IMMER* so geschrieben, sie wird definitiv aufgerufen, daher verwaltest du den Code von hier aus
fun main(args: Array<String>){
    // eine print Befehl ist recht simpel. Es ist eine schon vorhandene Funktion, die einen String nimmt und ihn in der
    // Console ausgiebt - println macht dann noch einen Zeilenumbruch dahinter
    print("Hello World - ")
    println("Siehst du ?")
    // Manuell kannst du es auch mit diesem \n machen
    print("\n")

    var x: Int = 5 //wir hatten ja schon Typen - so erstellst du sie nochmal, als Tipp ;)
    var y = intArrayOf(1,2,3) // wenn du extrem faul sein willst bei einem Array

    //um einen Array zu erstellen gibt es aber in manchen F√§llen mehr Einzelschritte
    var r: Array<Int> // gelesen: du erstellst eine Variabel(var) vom Typen Array(: Array), welcher Objekte
                      // vom Typ Integer enth√§lt(<Int>), r. <- aber so ist es halt ein Objekt vom Typ Integer ;3

    var s: IntArray   // jetzt ist es eben kein Zeiger auf ein Objekt vom Typ Integer, sondern ein Integer
                      // versuche es so zu machen, wenn du mit Integern arbeitest

    s = IntArray(3)   // jetzt sagst du erst welche Gr√∂√üe der hat und das MUSST du immer tun bevor du irgendwas mit dem machen willst
    s[0] = 1          // mit den eckigen Klammern gehst du auf das Element an der 0. Stelle und weist dem dann 1 zu

    // jetzt gucken wir uns Funktionen an - hier musst du im Code aus der jetztigen Funktion raus
    // der Befehl hier ruft den jetzt auf und springt an die Stelle im Code
    test()

    // jetzt wollen wir aber eine Rechnung auslagern und brauchen einen R√ºckgabewert
    // eine Funktion mit R√ºckgabewert k√∂nnen wir √ºbrigens nicht einfach so schreiben - wir m√ºssen den R√ºckgabewert schon benutzen
    s[1] = dice()

    //jetzt wollen wir einer Funktion einen Wert √ºbergeben
    s[2] = higherNumber(s[0],s[1])

    //jetzt wollen wir in weitere Stellen im Array schreiben, aber er ist voll, daher brauchen wir einen neuen
    var neuerS: IntArray = IntArray(6) // und doppelt so gro√ü üòà

    // jetzt fehlen aber die alten Objekte, aber wir k√∂nnen uns eine Funktion schreiben, die
    // den Array bekommt und einen neuen ausspuckt um ihn dem alten zuzuweisen.üòµ
    neuerS = array√úbergabe(s, neuerS.size)    // wir m√ºssen ja die l√§nge des neuen Arrays wissen. Nicht, dass wir jetzt etwas mit den anderen Elementen tun

    // eine while Schleife ist ziemlich simpel. Sie f√ºhrt solange etwas aus bis die Bedingung nicht mehr erf√ºllt ist
    while (s[1] != 6){
        s[1] = dice()
        print("| noch immer keine 6 |")
    }   // also w√ºrfelt der jetzt bis er eine Sechs hat

    // wir sind bald am Ende üò• - es fehlt aber noch ein when Statement
    // sagen wir wir wollen, dass unser Programm f√ºhr jede gew√ºrfelte Zahl etwas anderes ausgeben soll
    var geDiced: Int = dice() // oh man geDiced üòÇ

    when (geDiced){
        1 -> println("Du hast eine eins gew√ºrfelt.")
        2 -> println("Du hast eine zwei gew√ºrfelt.")
        3 -> println("Du hast eine drei gew√ºrfelt.")
        4 -> println("Du hast eine vier gew√ºrfelt.")
        5 -> println("Du hast eine f√ºnf gew√ºrfelt.")
        6 -> println("Du hast eine sechs gew√ºrfelt.")

        // eigentlich sind alle F√§lle abgedegt, aber falls nicht gibt es den genialen default
        else -> throw Exception("Irgendwas ist falsch.")
        // weil es eigentlich nicht passieren sollen throwen wir eine Exception um den Fehler dann zu identifizieren
        // ist aber noch unwichtig f√ºr dich
    }

    // und jetzt wirklich das letzte üòá .......... Casten

    // nehmen wir an wir haben einen Integer
    var unserInteger: Int = 6

    // aber wir brauchen einen double um weiterzumachen, dann k√∂nnen wir eben casten
    // das geht nicht immer - zb. gibt es Objekte, die vollkommen anders sind zu anderen
    // naja wie geht das Casten ?
    // ganz einfach - du schreibst *as*
    var unserDouble: Long = unserInteger as Long // das ist aber unsicher

    /* if (unserInteger as Long is Long){
    } */
    // casten wirst du aber wahrscheinlich selten nutzen üòÖ
}

fun test(){
    println("Die Funktion wurde aufgerufen.")
}

fun dice(): Int{ //: Int sagt jetzt welcher Typ es ist - kann auch irgendein Objekt vom Typ Luca sein sp√§ter ;)
    // jetzt benutzen wir die Library, die wir oben eingef√ºgt haben

    val rdm: Random = Random() // - das erstellt ein Objekt Random von Java, es hat verschiedene Funktionen auf die man zugreifen kann

    return rdm.nextInt(6)+1    // *return* gibt den Wert der dahinter steht zur√ºck und springt aus der Funktion
                               // zur√ºck zum anderen Code. rdm ist dein Objekt vom Typ random und mit dem Punkt kommst
                               // du an die Funktionen, die das Objekt ausf√ºhren soll
                               // nextInt erstellt eine zuf√§llige Zahl zwischen (0,1,...,n-1) das hei√üt bei 6
                               // zwischen 0 und 5 - mit +1 dahinter dann zwischen 1 und 6
}

fun higherNumber(s1: Int,s2: Int): Int{ //so wir bekommen jetzt zwei Zahlen s1 und s2 vom Typ Int

    if (s1 > s2)       {return s1} // wie ein if Statement funktioniert ist ganz simpel
    else if (s1 == s2) {return s2} // das else ist nur da, damit du wei√üt, dass man das einfach dahinter schreiben kann
    else               {return s2} // das mit dem else if genauso - ist gerade aber alles sehr redundant
}

fun array√úbergabe(alterS: IntArray,l√§ngeDesNeuen: Int): IntArray{  // hatten wir ja schon. Jetzt eben nur mit IntArray als Typ
    var neuerS: IntArray = kotlin.IntArray(l√§ngeDesNeuen)

    // jetzt ist es ein bisschen komplizierter
    // wir benutzen einen for loop und wie wir den schreiben ist definitiv anders als bei vielen Programmiersprachen
    // wir erstellen eine beliebige Variabel, in dem Fall x. Dann sagen wir 'in' um ein Intervall anzugeben
    // das geht jetzt von 0 bis die L√§nge und z√§hlt das letzte Element mit
    // das hei√üt (y in 0..10) z√§hlt 0,1,2,3,4,5,6,7,8,9,10
    for (x in 0..alterS.size-1){
        neuerS[x] = alterS[x]
    }

    return neuerS
}
